\subsection{Grammar}

In this section, we define some types and functions
about elementary definitions of formal language theories.

\begin{code}
module Grammar where

import Data.List
import Automaton

type Rule = (Symbol, SymbolString)
type RuleSet = [Rule]
type StartSymbol = Symbol
type TerminalSymbol = SymbolSet
type NonTerminalSymbol = SymbolSet
type Grammar = (TerminalSymbol, NonTerminalSymbol, RuleSet, StartSymbol)
\end{code}

A grammar is a four tuple $G=(T,N,R,S)$
of terminal symbols $T$, non-terminal symbols $N$,
transformation rules $R$ and a start symbol $S$.

Let \verb|s|=$T$.
For a string \verb|w| in $(T \cup N)^*$,
\verb|(terminalQ s w)| is {\bf True} if \verb|w| $ \in T^*$.

\begin{code}
terminalQ::TerminalSymbol->SymbolString->Bool
terminalQ _  []   = True
terminalQ s (h:t) | (h `elem` s) = terminalQ s t
                  | otherwise    = False
\end{code}

Let \verb|r| be a rule in $R$ and \verb|w| a string over $T \cup N$.
The set $\{w'| w \Rightarrow_{\{r\}} w'\}$ is computed by 
\verb|(gonestep r w)|.

\begin{code}
onestep::Rule->SymbolString->[SymbolString]
onestep (l,r) []  =  []
onestep (l,r) s@(h:t)|  (h == l)  = nub (a++[r++t])
                      |  otherwise = a
        where a = nub $ (map ([h]++) (onestep (l,r) t)) \\ [s]

onestep'::RuleSet->SymbolString->[SymbolString]
onestep' rs s = nub $ concat [Grammar.onestep r s | r <- rs]
\end{code}

The language $L(G)$ generated by a grammar $G=(\Sigma,N,R,S)$
is defined as follows.
$$
L(G) = \{w \in \Sigma^* | S \Rightarrow_G^* w\}
$$
For a grammar \verb|g|$=G$, \verb|(Grammar.language g)|
compute the $L(G)$.

\begin{code}
language::Grammar->[SymbolString]
language g@(t,n,rs,s0) = filter (Grammar.terminalQ t) 
                                (Grammar.generate g)

generate::Grammar->[SymbolString]
generate g@(t,n,rs,s0) =  (sstep (Grammar.onestep' rs)) [[s0]]

fgen::(SymbolString->Bool)->Grammar->Symbol->[SymbolString]
fgen f g@(t,n,rs,s0) s1 =  filter (Grammar.terminalQ t)
                           ((sfstep f (Grammar.onestep' rs)) [[s1]])

ffgen::(SymbolString->Bool)->Grammar->Symbol->Symbol->[SymbolString]
ffgen f g@(t,n,rs,s0) s1 s2 = filter (elem s2) 
                            ((sfstep f (Grammar.onestep' rs)) [[s1]])
\end{code}

\subsection{Linear Grammar}

\begin{code}
lincheck::Grammar->Bool
lincheck g@(t,n,rs,s0) = and $ map f rs
         where f (c,s) = lincheck' n s

lincheck'::NonTerminalSymbol->SymbolString->Bool
lincheck' n w = (length (filter (\x->(x `elem` n)) w)) <= 1

lpart::NonTerminalSymbol->SymbolString->SymbolString
lpart n []    = []
lpart n (h:t) | (h `elem` n)   = []
              | otherwise = [h]++(lpart n t)

rpart::NonTerminalSymbol->SymbolString->SymbolString
rpart n []    = []
rpart n (h:t) | (h `elem` n)   = t
              | otherwise = rpart n t

jpart::NonTerminalSymbol->SymbolString->Int
jpart n [] = 0
jpart n (h:t) | (h `elem` n) = ((head (elemIndices h n))+1)
              | otherwise = jpart n t
\end{code}

